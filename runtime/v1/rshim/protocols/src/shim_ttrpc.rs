// This file is generated by ttrpc-compiler 0.3.2. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clipto_camel_casepy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
use protobuf::{CodedInputStream, CodedOutputStream, Message};
use std::collections::HashMap;
use std::sync::Arc;

#[derive(Clone)]
pub struct ShimClient {
    client: ::ttrpc::Client,
}

impl ShimClient {
    pub fn new(client: ::ttrpc::Client) -> Self {
        ShimClient {
            client: client,
        }
    }

    pub fn state(&self, req: &super::shim::StateRequest, timeout_nano: i64) -> ::ttrpc::Result<super::shim::StateResponse> {
        let mut cres = super::shim::StateResponse::new();
        ::ttrpc::client_request!(self, req, timeout_nano, "containerd.runtime.linux.shim.v1.Shim", "State", cres);
        Ok(cres)
    }

    pub fn create(&self, req: &super::shim::CreateTaskRequest, timeout_nano: i64) -> ::ttrpc::Result<super::shim::CreateTaskResponse> {
        let mut cres = super::shim::CreateTaskResponse::new();
        ::ttrpc::client_request!(self, req, timeout_nano, "containerd.runtime.linux.shim.v1.Shim", "Create", cres);
        Ok(cres)
    }

    pub fn start(&self, req: &super::shim::StartRequest, timeout_nano: i64) -> ::ttrpc::Result<super::shim::StartResponse> {
        let mut cres = super::shim::StartResponse::new();
        ::ttrpc::client_request!(self, req, timeout_nano, "containerd.runtime.linux.shim.v1.Shim", "Start", cres);
        Ok(cres)
    }

    pub fn delete(&self, req: &super::empty::Empty, timeout_nano: i64) -> ::ttrpc::Result<super::shim::DeleteResponse> {
        let mut cres = super::shim::DeleteResponse::new();
        ::ttrpc::client_request!(self, req, timeout_nano, "containerd.runtime.linux.shim.v1.Shim", "Delete", cres);
        Ok(cres)
    }

    pub fn delete_process(&self, req: &super::shim::DeleteProcessRequest, timeout_nano: i64) -> ::ttrpc::Result<super::shim::DeleteResponse> {
        let mut cres = super::shim::DeleteResponse::new();
        ::ttrpc::client_request!(self, req, timeout_nano, "containerd.runtime.linux.shim.v1.Shim", "DeleteProcess", cres);
        Ok(cres)
    }

    pub fn list_pids(&self, req: &super::shim::ListPidsRequest, timeout_nano: i64) -> ::ttrpc::Result<super::shim::ListPidsResponse> {
        let mut cres = super::shim::ListPidsResponse::new();
        ::ttrpc::client_request!(self, req, timeout_nano, "containerd.runtime.linux.shim.v1.Shim", "ListPids", cres);
        Ok(cres)
    }

    pub fn pause(&self, req: &super::empty::Empty, timeout_nano: i64) -> ::ttrpc::Result<super::empty::Empty> {
        let mut cres = super::empty::Empty::new();
        ::ttrpc::client_request!(self, req, timeout_nano, "containerd.runtime.linux.shim.v1.Shim", "Pause", cres);
        Ok(cres)
    }

    pub fn resume(&self, req: &super::empty::Empty, timeout_nano: i64) -> ::ttrpc::Result<super::empty::Empty> {
        let mut cres = super::empty::Empty::new();
        ::ttrpc::client_request!(self, req, timeout_nano, "containerd.runtime.linux.shim.v1.Shim", "Resume", cres);
        Ok(cres)
    }

    pub fn checkpoint(&self, req: &super::shim::CheckpointTaskRequest, timeout_nano: i64) -> ::ttrpc::Result<super::empty::Empty> {
        let mut cres = super::empty::Empty::new();
        ::ttrpc::client_request!(self, req, timeout_nano, "containerd.runtime.linux.shim.v1.Shim", "Checkpoint", cres);
        Ok(cres)
    }

    pub fn kill(&self, req: &super::shim::KillRequest, timeout_nano: i64) -> ::ttrpc::Result<super::empty::Empty> {
        let mut cres = super::empty::Empty::new();
        ::ttrpc::client_request!(self, req, timeout_nano, "containerd.runtime.linux.shim.v1.Shim", "Kill", cres);
        Ok(cres)
    }

    pub fn exec(&self, req: &super::shim::ExecProcessRequest, timeout_nano: i64) -> ::ttrpc::Result<super::empty::Empty> {
        let mut cres = super::empty::Empty::new();
        ::ttrpc::client_request!(self, req, timeout_nano, "containerd.runtime.linux.shim.v1.Shim", "Exec", cres);
        Ok(cres)
    }

    pub fn resize_pty(&self, req: &super::shim::ResizePtyRequest, timeout_nano: i64) -> ::ttrpc::Result<super::empty::Empty> {
        let mut cres = super::empty::Empty::new();
        ::ttrpc::client_request!(self, req, timeout_nano, "containerd.runtime.linux.shim.v1.Shim", "ResizePty", cres);
        Ok(cres)
    }

    pub fn close_io(&self, req: &super::shim::CloseIORequest, timeout_nano: i64) -> ::ttrpc::Result<super::empty::Empty> {
        let mut cres = super::empty::Empty::new();
        ::ttrpc::client_request!(self, req, timeout_nano, "containerd.runtime.linux.shim.v1.Shim", "CloseIO", cres);
        Ok(cres)
    }

    pub fn shim_info(&self, req: &super::empty::Empty, timeout_nano: i64) -> ::ttrpc::Result<super::shim::ShimInfoResponse> {
        let mut cres = super::shim::ShimInfoResponse::new();
        ::ttrpc::client_request!(self, req, timeout_nano, "containerd.runtime.linux.shim.v1.Shim", "ShimInfo", cres);
        Ok(cres)
    }

    pub fn update(&self, req: &super::shim::UpdateTaskRequest, timeout_nano: i64) -> ::ttrpc::Result<super::empty::Empty> {
        let mut cres = super::empty::Empty::new();
        ::ttrpc::client_request!(self, req, timeout_nano, "containerd.runtime.linux.shim.v1.Shim", "Update", cres);
        Ok(cres)
    }

    pub fn wait(&self, req: &super::shim::WaitRequest, timeout_nano: i64) -> ::ttrpc::Result<super::shim::WaitResponse> {
        let mut cres = super::shim::WaitResponse::new();
        ::ttrpc::client_request!(self, req, timeout_nano, "containerd.runtime.linux.shim.v1.Shim", "Wait", cres);
        Ok(cres)
    }
}

struct StateMethod {
    service: Arc<std::boxed::Box<dyn Shim + Send + Sync>>,
}

impl ::ttrpc::MethodHandler for StateMethod {
    fn handler(&self, ctx: ::ttrpc::TtrpcContext, req: ::ttrpc::Request) -> ::ttrpc::Result<()> {
        ::ttrpc::request_handler!(self, ctx, req, shim, StateRequest, state);
        Ok(())
    }
}

struct CreateMethod {
    service: Arc<std::boxed::Box<dyn Shim + Send + Sync>>,
}

impl ::ttrpc::MethodHandler for CreateMethod {
    fn handler(&self, ctx: ::ttrpc::TtrpcContext, req: ::ttrpc::Request) -> ::ttrpc::Result<()> {
        ::ttrpc::request_handler!(self, ctx, req, shim, CreateTaskRequest, create);
        Ok(())
    }
}

struct StartMethod {
    service: Arc<std::boxed::Box<dyn Shim + Send + Sync>>,
}

impl ::ttrpc::MethodHandler for StartMethod {
    fn handler(&self, ctx: ::ttrpc::TtrpcContext, req: ::ttrpc::Request) -> ::ttrpc::Result<()> {
        ::ttrpc::request_handler!(self, ctx, req, shim, StartRequest, start);
        Ok(())
    }
}

struct DeleteMethod {
    service: Arc<std::boxed::Box<dyn Shim + Send + Sync>>,
}

impl ::ttrpc::MethodHandler for DeleteMethod {
    fn handler(&self, ctx: ::ttrpc::TtrpcContext, req: ::ttrpc::Request) -> ::ttrpc::Result<()> {
        ::ttrpc::request_handler!(self, ctx, req, empty, Empty, delete);
        Ok(())
    }
}

struct DeleteProcessMethod {
    service: Arc<std::boxed::Box<dyn Shim + Send + Sync>>,
}

impl ::ttrpc::MethodHandler for DeleteProcessMethod {
    fn handler(&self, ctx: ::ttrpc::TtrpcContext, req: ::ttrpc::Request) -> ::ttrpc::Result<()> {
        ::ttrpc::request_handler!(self, ctx, req, shim, DeleteProcessRequest, delete_process);
        Ok(())
    }
}

struct ListPidsMethod {
    service: Arc<std::boxed::Box<dyn Shim + Send + Sync>>,
}

impl ::ttrpc::MethodHandler for ListPidsMethod {
    fn handler(&self, ctx: ::ttrpc::TtrpcContext, req: ::ttrpc::Request) -> ::ttrpc::Result<()> {
        ::ttrpc::request_handler!(self, ctx, req, shim, ListPidsRequest, list_pids);
        Ok(())
    }
}

struct PauseMethod {
    service: Arc<std::boxed::Box<dyn Shim + Send + Sync>>,
}

impl ::ttrpc::MethodHandler for PauseMethod {
    fn handler(&self, ctx: ::ttrpc::TtrpcContext, req: ::ttrpc::Request) -> ::ttrpc::Result<()> {
        ::ttrpc::request_handler!(self, ctx, req, empty, Empty, pause);
        Ok(())
    }
}

struct ResumeMethod {
    service: Arc<std::boxed::Box<dyn Shim + Send + Sync>>,
}

impl ::ttrpc::MethodHandler for ResumeMethod {
    fn handler(&self, ctx: ::ttrpc::TtrpcContext, req: ::ttrpc::Request) -> ::ttrpc::Result<()> {
        ::ttrpc::request_handler!(self, ctx, req, empty, Empty, resume);
        Ok(())
    }
}

struct CheckpointMethod {
    service: Arc<std::boxed::Box<dyn Shim + Send + Sync>>,
}

impl ::ttrpc::MethodHandler for CheckpointMethod {
    fn handler(&self, ctx: ::ttrpc::TtrpcContext, req: ::ttrpc::Request) -> ::ttrpc::Result<()> {
        ::ttrpc::request_handler!(self, ctx, req, shim, CheckpointTaskRequest, checkpoint);
        Ok(())
    }
}

struct KillMethod {
    service: Arc<std::boxed::Box<dyn Shim + Send + Sync>>,
}

impl ::ttrpc::MethodHandler for KillMethod {
    fn handler(&self, ctx: ::ttrpc::TtrpcContext, req: ::ttrpc::Request) -> ::ttrpc::Result<()> {
        ::ttrpc::request_handler!(self, ctx, req, shim, KillRequest, kill);
        Ok(())
    }
}

struct ExecMethod {
    service: Arc<std::boxed::Box<dyn Shim + Send + Sync>>,
}

impl ::ttrpc::MethodHandler for ExecMethod {
    fn handler(&self, ctx: ::ttrpc::TtrpcContext, req: ::ttrpc::Request) -> ::ttrpc::Result<()> {
        ::ttrpc::request_handler!(self, ctx, req, shim, ExecProcessRequest, exec);
        Ok(())
    }
}

struct ResizePtyMethod {
    service: Arc<std::boxed::Box<dyn Shim + Send + Sync>>,
}

impl ::ttrpc::MethodHandler for ResizePtyMethod {
    fn handler(&self, ctx: ::ttrpc::TtrpcContext, req: ::ttrpc::Request) -> ::ttrpc::Result<()> {
        ::ttrpc::request_handler!(self, ctx, req, shim, ResizePtyRequest, resize_pty);
        Ok(())
    }
}

struct CloseIoMethod {
    service: Arc<std::boxed::Box<dyn Shim + Send + Sync>>,
}

impl ::ttrpc::MethodHandler for CloseIoMethod {
    fn handler(&self, ctx: ::ttrpc::TtrpcContext, req: ::ttrpc::Request) -> ::ttrpc::Result<()> {
        ::ttrpc::request_handler!(self, ctx, req, shim, CloseIORequest, close_io);
        Ok(())
    }
}

struct ShimInfoMethod {
    service: Arc<std::boxed::Box<dyn Shim + Send + Sync>>,
}

impl ::ttrpc::MethodHandler for ShimInfoMethod {
    fn handler(&self, ctx: ::ttrpc::TtrpcContext, req: ::ttrpc::Request) -> ::ttrpc::Result<()> {
        ::ttrpc::request_handler!(self, ctx, req, empty, Empty, shim_info);
        Ok(())
    }
}

struct UpdateMethod {
    service: Arc<std::boxed::Box<dyn Shim + Send + Sync>>,
}

impl ::ttrpc::MethodHandler for UpdateMethod {
    fn handler(&self, ctx: ::ttrpc::TtrpcContext, req: ::ttrpc::Request) -> ::ttrpc::Result<()> {
        ::ttrpc::request_handler!(self, ctx, req, shim, UpdateTaskRequest, update);
        Ok(())
    }
}

struct WaitMethod {
    service: Arc<std::boxed::Box<dyn Shim + Send + Sync>>,
}

impl ::ttrpc::MethodHandler for WaitMethod {
    fn handler(&self, ctx: ::ttrpc::TtrpcContext, req: ::ttrpc::Request) -> ::ttrpc::Result<()> {
        ::ttrpc::request_handler!(self, ctx, req, shim, WaitRequest, wait);
        Ok(())
    }
}

pub trait Shim {
    fn state(&self, _ctx: &::ttrpc::TtrpcContext, _req: super::shim::StateRequest) -> ::ttrpc::Result<super::shim::StateResponse> {
        Err(::ttrpc::Error::RpcStatus(::ttrpc::get_status(::ttrpc::Code::NOT_FOUND, "/containerd.runtime.linux.shim.v1.Shim/State is not supported".to_string())))
    }
    fn create(&self, _ctx: &::ttrpc::TtrpcContext, _req: super::shim::CreateTaskRequest) -> ::ttrpc::Result<super::shim::CreateTaskResponse> {
        Err(::ttrpc::Error::RpcStatus(::ttrpc::get_status(::ttrpc::Code::NOT_FOUND, "/containerd.runtime.linux.shim.v1.Shim/Create is not supported".to_string())))
    }
    fn start(&self, _ctx: &::ttrpc::TtrpcContext, _req: super::shim::StartRequest) -> ::ttrpc::Result<super::shim::StartResponse> {
        Err(::ttrpc::Error::RpcStatus(::ttrpc::get_status(::ttrpc::Code::NOT_FOUND, "/containerd.runtime.linux.shim.v1.Shim/Start is not supported".to_string())))
    }
    fn delete(&self, _ctx: &::ttrpc::TtrpcContext, _req: super::empty::Empty) -> ::ttrpc::Result<super::shim::DeleteResponse> {
        Err(::ttrpc::Error::RpcStatus(::ttrpc::get_status(::ttrpc::Code::NOT_FOUND, "/containerd.runtime.linux.shim.v1.Shim/Delete is not supported".to_string())))
    }
    fn delete_process(&self, _ctx: &::ttrpc::TtrpcContext, _req: super::shim::DeleteProcessRequest) -> ::ttrpc::Result<super::shim::DeleteResponse> {
        Err(::ttrpc::Error::RpcStatus(::ttrpc::get_status(::ttrpc::Code::NOT_FOUND, "/containerd.runtime.linux.shim.v1.Shim/DeleteProcess is not supported".to_string())))
    }
    fn list_pids(&self, _ctx: &::ttrpc::TtrpcContext, _req: super::shim::ListPidsRequest) -> ::ttrpc::Result<super::shim::ListPidsResponse> {
        Err(::ttrpc::Error::RpcStatus(::ttrpc::get_status(::ttrpc::Code::NOT_FOUND, "/containerd.runtime.linux.shim.v1.Shim/ListPids is not supported".to_string())))
    }
    fn pause(&self, _ctx: &::ttrpc::TtrpcContext, _req: super::empty::Empty) -> ::ttrpc::Result<super::empty::Empty> {
        Err(::ttrpc::Error::RpcStatus(::ttrpc::get_status(::ttrpc::Code::NOT_FOUND, "/containerd.runtime.linux.shim.v1.Shim/Pause is not supported".to_string())))
    }
    fn resume(&self, _ctx: &::ttrpc::TtrpcContext, _req: super::empty::Empty) -> ::ttrpc::Result<super::empty::Empty> {
        Err(::ttrpc::Error::RpcStatus(::ttrpc::get_status(::ttrpc::Code::NOT_FOUND, "/containerd.runtime.linux.shim.v1.Shim/Resume is not supported".to_string())))
    }
    fn checkpoint(&self, _ctx: &::ttrpc::TtrpcContext, _req: super::shim::CheckpointTaskRequest) -> ::ttrpc::Result<super::empty::Empty> {
        Err(::ttrpc::Error::RpcStatus(::ttrpc::get_status(::ttrpc::Code::NOT_FOUND, "/containerd.runtime.linux.shim.v1.Shim/Checkpoint is not supported".to_string())))
    }
    fn kill(&self, _ctx: &::ttrpc::TtrpcContext, _req: super::shim::KillRequest) -> ::ttrpc::Result<super::empty::Empty> {
        Err(::ttrpc::Error::RpcStatus(::ttrpc::get_status(::ttrpc::Code::NOT_FOUND, "/containerd.runtime.linux.shim.v1.Shim/Kill is not supported".to_string())))
    }
    fn exec(&self, _ctx: &::ttrpc::TtrpcContext, _req: super::shim::ExecProcessRequest) -> ::ttrpc::Result<super::empty::Empty> {
        Err(::ttrpc::Error::RpcStatus(::ttrpc::get_status(::ttrpc::Code::NOT_FOUND, "/containerd.runtime.linux.shim.v1.Shim/Exec is not supported".to_string())))
    }
    fn resize_pty(&self, _ctx: &::ttrpc::TtrpcContext, _req: super::shim::ResizePtyRequest) -> ::ttrpc::Result<super::empty::Empty> {
        Err(::ttrpc::Error::RpcStatus(::ttrpc::get_status(::ttrpc::Code::NOT_FOUND, "/containerd.runtime.linux.shim.v1.Shim/ResizePty is not supported".to_string())))
    }
    fn close_io(&self, _ctx: &::ttrpc::TtrpcContext, _req: super::shim::CloseIORequest) -> ::ttrpc::Result<super::empty::Empty> {
        Err(::ttrpc::Error::RpcStatus(::ttrpc::get_status(::ttrpc::Code::NOT_FOUND, "/containerd.runtime.linux.shim.v1.Shim/CloseIO is not supported".to_string())))
    }
    fn shim_info(&self, _ctx: &::ttrpc::TtrpcContext, _req: super::empty::Empty) -> ::ttrpc::Result<super::shim::ShimInfoResponse> {
        Err(::ttrpc::Error::RpcStatus(::ttrpc::get_status(::ttrpc::Code::NOT_FOUND, "/containerd.runtime.linux.shim.v1.Shim/ShimInfo is not supported".to_string())))
    }
    fn update(&self, _ctx: &::ttrpc::TtrpcContext, _req: super::shim::UpdateTaskRequest) -> ::ttrpc::Result<super::empty::Empty> {
        Err(::ttrpc::Error::RpcStatus(::ttrpc::get_status(::ttrpc::Code::NOT_FOUND, "/containerd.runtime.linux.shim.v1.Shim/Update is not supported".to_string())))
    }
    fn wait(&self, _ctx: &::ttrpc::TtrpcContext, _req: super::shim::WaitRequest) -> ::ttrpc::Result<super::shim::WaitResponse> {
        Err(::ttrpc::Error::RpcStatus(::ttrpc::get_status(::ttrpc::Code::NOT_FOUND, "/containerd.runtime.linux.shim.v1.Shim/Wait is not supported".to_string())))
    }
}

pub fn create_shim(service: Arc<std::boxed::Box<dyn Shim + Send + Sync>>) -> HashMap <String, Box<dyn ::ttrpc::MethodHandler + Send + Sync>> {
    let mut methods = HashMap::new();

    methods.insert("/containerd.runtime.linux.shim.v1.Shim/State".to_string(),
                    std::boxed::Box::new(StateMethod{service: service.clone()}) as std::boxed::Box<dyn ::ttrpc::MethodHandler + Send + Sync>);

    methods.insert("/containerd.runtime.linux.shim.v1.Shim/Create".to_string(),
                    std::boxed::Box::new(CreateMethod{service: service.clone()}) as std::boxed::Box<dyn ::ttrpc::MethodHandler + Send + Sync>);

    methods.insert("/containerd.runtime.linux.shim.v1.Shim/Start".to_string(),
                    std::boxed::Box::new(StartMethod{service: service.clone()}) as std::boxed::Box<dyn ::ttrpc::MethodHandler + Send + Sync>);

    methods.insert("/containerd.runtime.linux.shim.v1.Shim/Delete".to_string(),
                    std::boxed::Box::new(DeleteMethod{service: service.clone()}) as std::boxed::Box<dyn ::ttrpc::MethodHandler + Send + Sync>);

    methods.insert("/containerd.runtime.linux.shim.v1.Shim/DeleteProcess".to_string(),
                    std::boxed::Box::new(DeleteProcessMethod{service: service.clone()}) as std::boxed::Box<dyn ::ttrpc::MethodHandler + Send + Sync>);

    methods.insert("/containerd.runtime.linux.shim.v1.Shim/ListPids".to_string(),
                    std::boxed::Box::new(ListPidsMethod{service: service.clone()}) as std::boxed::Box<dyn ::ttrpc::MethodHandler + Send + Sync>);

    methods.insert("/containerd.runtime.linux.shim.v1.Shim/Pause".to_string(),
                    std::boxed::Box::new(PauseMethod{service: service.clone()}) as std::boxed::Box<dyn ::ttrpc::MethodHandler + Send + Sync>);

    methods.insert("/containerd.runtime.linux.shim.v1.Shim/Resume".to_string(),
                    std::boxed::Box::new(ResumeMethod{service: service.clone()}) as std::boxed::Box<dyn ::ttrpc::MethodHandler + Send + Sync>);

    methods.insert("/containerd.runtime.linux.shim.v1.Shim/Checkpoint".to_string(),
                    std::boxed::Box::new(CheckpointMethod{service: service.clone()}) as std::boxed::Box<dyn ::ttrpc::MethodHandler + Send + Sync>);

    methods.insert("/containerd.runtime.linux.shim.v1.Shim/Kill".to_string(),
                    std::boxed::Box::new(KillMethod{service: service.clone()}) as std::boxed::Box<dyn ::ttrpc::MethodHandler + Send + Sync>);

    methods.insert("/containerd.runtime.linux.shim.v1.Shim/Exec".to_string(),
                    std::boxed::Box::new(ExecMethod{service: service.clone()}) as std::boxed::Box<dyn ::ttrpc::MethodHandler + Send + Sync>);

    methods.insert("/containerd.runtime.linux.shim.v1.Shim/ResizePty".to_string(),
                    std::boxed::Box::new(ResizePtyMethod{service: service.clone()}) as std::boxed::Box<dyn ::ttrpc::MethodHandler + Send + Sync>);

    methods.insert("/containerd.runtime.linux.shim.v1.Shim/CloseIO".to_string(),
                    std::boxed::Box::new(CloseIoMethod{service: service.clone()}) as std::boxed::Box<dyn ::ttrpc::MethodHandler + Send + Sync>);

    methods.insert("/containerd.runtime.linux.shim.v1.Shim/ShimInfo".to_string(),
                    std::boxed::Box::new(ShimInfoMethod{service: service.clone()}) as std::boxed::Box<dyn ::ttrpc::MethodHandler + Send + Sync>);

    methods.insert("/containerd.runtime.linux.shim.v1.Shim/Update".to_string(),
                    std::boxed::Box::new(UpdateMethod{service: service.clone()}) as std::boxed::Box<dyn ::ttrpc::MethodHandler + Send + Sync>);

    methods.insert("/containerd.runtime.linux.shim.v1.Shim/Wait".to_string(),
                    std::boxed::Box::new(WaitMethod{service: service.clone()}) as std::boxed::Box<dyn ::ttrpc::MethodHandler + Send + Sync>);

    methods
}
